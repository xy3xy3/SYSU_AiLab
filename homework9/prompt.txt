## 深度学习

### 中药图片分类任务

利用pytorch框架搭建神经网络实现中药图片分类，其中中药图片数据分为训练集`train`和测试集`test`，训练集仅用于网络训练阶段，测试集仅用于模型的性能测试阶段。训练集和测试集均包含五种不同类型的中药图片：`baihe`、`dangshen`、`gouqi`、`huaihua`、`jinyinhua`。请合理设计神经网络架构，利用训练集完成网络训练，统计网络模型的训练准确率和测试准确率，画出模型的训练过程的loss曲线、准确率曲线。

### 提示

1. 最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.
2. 本次作业可以使用 `pytorch`相关的库、`numpy`库、`matplotlib`库以及python标准库.
3. 数据集可以在Github上下载。
4. 模型的训练性能以及测试性能均作为本次作业的评分标准。
5. 测试集不可用于模型训练。

# 你的任务
文件夹规则如下：
```
./test/*.jpg
无二级目录
./train/(`baihe`、`dangshen`、`gouqi`、`huaihua`、`jinyinhua`)/*.jpg
含有二级目录
PS E:\BaiduSyncdisk\文档类\AiLab\homework9\Code> ls -l test


    目录: E:\BaiduSyncdisk\文档类\AiLab\homework9\Code\test


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2022-05-25     21:55          23005 baihe01.jpg
-a----        2022-05-25     21:55          24956 baihe02.jpg
-a----        2022-05-25     21:55         175489 dangshen01.jpg
-a----        2022-05-25     21:55          54133 dangshen02.jpg
-a----        2022-05-25     21:55          21243 gouqi01.jpg
-a----        2022-05-25     21:55          41871 gouqi02.jpg
-a----        2022-05-25     21:55          55123 huaihua01.jpg
-a----        2022-05-25     21:55          42676 huaihua02.jpg
-a----        2022-05-25     21:55          86460 jinyinhua01.jpg
-a----        2022-05-25     21:55          29692 jinyinhua02.jpg


PS E:\BaiduSyncdisk\文档类\AiLab\homework9\Code> ls -l train


    目录: E:\BaiduSyncdisk\文档类\AiLab\homework9\Code\train


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        2024-05-14     16:53                baihe
d-----        2024-05-14     16:53                dangshen
d-----        2024-05-14     16:53                gouqi
d-----        2024-05-14     16:54                huaihua
d-----        2024-05-14     16:54                jinyinhua
```
你需要通过
```
train_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "./train").replace("\\", "/")
test_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "./test").replace("\\", "/")
```
获取文件夹，然后对于train，你可能需要打开二级文件夹

训练目标是输入图片，得到他的分类：`baihe`、`dangshen`、`gouqi`、`huaihua`、`jinyinhua`
对于test的数据，可以通过去除文件名字后缀和编号来知道他是哪个分类

```python
import os
import torch
import torchvision
import torchvision.transforms as transforms
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader, Dataset
from torchvision import models
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from PIL import Image

model_dir = os.path.dirname(os.path.abspath(__file__)).replace("\\", "/")
# 自定义Dataset类用于加载测试集
class TestDataset(Dataset):
    def __init__(self, root, transform=None):
        self.root = root
        self.transform = transform
        self.images = []
        self.labels = []
        self.classes = ['baihe', 'dangshen', 'gouqi', 'huaihua', 'jinyinhua']
        self.class_to_idx = {cls: idx for idx, cls in enumerate(self.classes)}
        for filename in os.listdir(root):
            for cls in self.classes:
                if filename.startswith(cls):
                    self.images.append(os.path.join(root, filename))
                    self.labels.append(self.class_to_idx[cls])
                    break

    def __len__(self):
        return len(self.images)

    def __getitem__(self, idx):
        image_path = self.images[idx]
        image = Image.open(image_path).convert("RGB")  # 使用 PIL 读取图像
        if self.transform:
            image = self.transform(image)
        label = self.labels[idx]
        return image, label

def main():
    # 设置文件夹路径
    train_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "./train").replace("\\", "/")
    test_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "./test").replace("\\", "/")

    # 定义数据预处理
    transform = transforms.Compose([
        transforms.Resize((224, 224)),  # 调整图片大小为224x224
        transforms.ToTensor(),  # 将图片转换为Tensor
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # 标准化
    ])

    # 加载训练集
    train_dataset = ImageFolder(root=train_dir, transform=transform)
    test_dataset = TestDataset(root=test_dir, transform=transform)

    # 数据加载器
    train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
    test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

    # 加载预训练的ResNet模型
    weights = models.ResNet18_Weights.IMAGENET1K_V1
    model = models.resnet18(weights=weights)
    num_ftrs = model.fc.in_features

    # 修改最后一层为5个输出
    model.fc = nn.Linear(num_ftrs, 5)

    # 检查是否有可用的GPU
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = model.to(device)

    # 定义损失函数和优化器
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)

    # 训练模型
    num_epochs = 25
    best_acc = 0.0
    train_acc_history = []
    test_acc_history = []
    train_loss_history = []

    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0

        for inputs, labels in train_loader:
            inputs, labels = inputs.to(device), labels.to(device)
            optimizer.zero_grad()

            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

            running_loss += loss.item() * inputs.size(0)
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

        epoch_loss = running_loss / len(train_loader.dataset)
        epoch_acc = correct / total

        train_loss_history.append(epoch_loss)
        train_acc_history.append(epoch_acc)

        print(f'Epoch {epoch+1}/{num_epochs}, Loss: {epoch_loss:.4f}, Accuracy: {epoch_acc:.4f}')

        # 测试模型
        model.eval()
        correct = 0
        total = 0

        with torch.no_grad():
            for inputs, labels in test_loader:
                inputs, labels = inputs.to(device), labels.to(device)
                outputs = model(inputs)
                _, predicted = torch.max(outputs, 1)
                total += labels.size(0)
                correct += (predicted == labels).sum().item()

        test_acc = correct / total
        test_acc_history.append(test_acc)
        print(f'Test Accuracy: {test_acc:.4f}')

        # 保存性能最好的模型
        if test_acc > best_acc:
            best_acc = test_acc
            torch.save(model.state_dict(), model_dir+'best_model.pth')

    # 画出损失曲线和准确率曲线
    plt.figure()
    plt.plot(train_loss_history, label='Train Loss')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.title('Train Loss Curve')
    plt.legend()
    plt.show()

    plt.figure()
    plt.plot(train_acc_history, label='Train Accuracy')
    plt.plot(test_acc_history, label='Test Accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.title('Accuracy Curve')
    plt.legend()
    plt.show()

def load_and_test_model(model_path, test_loader, device):
    model = models.resnet18(weights=models.ResNet18_Weights.IMAGENET1K_V1)
    num_ftrs = model.fc.in_features
    model.fc = nn.Linear(num_ftrs, 5)
    model.load_state_dict(torch.load(model_path))
    model = model.to(device)
    model.eval()

    correct = 0
    total = 0

    with torch.no_grad():
        for inputs, labels in test_loader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    test_acc = correct / total
    print(f'Loaded model Test Accuracy: {test_acc:.4f}')
    return test_acc

if __name__ == "__main__":
    main()

```
目前十个图片预测经过20轮还是0.9，请尝试优化学习算法