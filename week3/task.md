# 归结算法：
## Clausal form (便于计算机处理的形式)
- 每一个子句对应一个元组，元组每一个元素是一个原子公式/原子公式的否定，
元素之间的关系是析取关系，表示只要一个原子成立，该子句成立
- 如子句¬child˅¬male˅boy对应数据结构(¬child,¬male,boy)，空子句()对应False
- 元组的集合组成子句集S，子句集中每个句子之间是合取关系，表示每一个
子句都应该被满足
- 由于本次实验重点是归结算法，所以问题输入是已经转换过的clausal form，
关于具体转换方式感兴趣的同学可以参考课件

## 单步归结
- 从两个子句中分别寻找相同的原子，及其对应的原子否定
- 去掉该原子并将两个子句合为一个，加入到S子句集合中
- 例如(¬child,¬female,girl)和(child)合并为(¬female,girl)

最一般合一算法：
#  合一（unifier）：
- 通过变量替换使得两个子句能够被归结（有相同的原子），所以合一也被
定义为使得两个原子公式等价的一组变量替换/赋值
- 由于一阶逻辑中存在变量，所以归结之前需要进行合一，如
(P(john),Q(fred),R(x))和(¬P(y),R(susan),R(y))两个子句中，我们无法找到一样
的原子及其对应的否定，但是不代表它们不能够归结
- 通过将y替换为john，我们得到了(P(john),Q(fred),R(x))和
(¬P(john),R(susan),R(john))，此时我们两个子句分别存在原子P(john)和它的
否定¬P(john)，可以进行归结
#  最一般合一：指使得两个原子公式等价，最简单的一组变量替换


输入：两个原子公式，它们具有相同的谓词，不同的参数项和¬

输出：一组变量替换/赋值
 算法流程：
 $\square\quad \mathrm{k= 0; \sigma_0= \{ \} ; S_0= \{ f, g\} }$

如果S$_{\kappa}$中的公式等价，返回$\sigma_k$作为最一般合一的结果 W 否则找出$s_k$中的不匹配项$D_k= \{ $el$, $e$2\} $

如果 el=V 是变量，e2-t是一个不包含变量V的项，将“V=t”添加到赋值集合$\sigma_{k+1}=\sigma_k\cup\{V=t\};$ 并将$S_k$中的其它V变量也赋值为t，得到$S_{k+1}$ $k=k+1$,转到第二步

否则合一失败

# 存储公式的python数据结构
- 用字符串存储
- 符号¬用"~"代替
- 谓词的首字母大写, 例如用A, B, C, P1, P2, Student等表
示; 谓词的每个参数之间用逗号“,”间隔且不加空格
- 常量用小写单词或a, b, c等小写字母表示;
- 本次作业的公式中不含∃,∀量词符号
- 例子: ¬child存储为 “~child” boy存储为“boy”
- 几个公式: “R(a)”, “~P(a,zz)”, “Student(tony)”. 这里应该将a,tony
看做常量,将zz看做变量

# 存储子句的python数据结构
- 用tuple的方式存储
- 例子: 
- ¬child˅¬male˅boy存储为("~child", "~male", "boy")
- ¬S(z) ˅ L(z, snow)存储为("~S(z)", "L(z,snow)")

# 存储子句集的python数据结构
- 子句集用set的方式存储, 每个元素是子句(元组)